{"code":"Room.prototype.get = function (roomObjectName) {\r\n    const room = this;\r\n    // Check if value is cached. If so then return it\r\n    let cachedValue;\r\n    cachedValue = findRoomObjectInGlobal(roomObjectName);\r\n    if (cachedValue)\r\n        return cachedValue;\r\n    cachedValue = findRoomObjectInMemory(roomObjectName);\r\n    if (cachedValue)\r\n        return cachedValue;\r\n    /**\r\n     *\r\n     * @param roomObjectName name of roomObject\r\n     * @returns roomObject\r\n     */\r\n    function findRoomObjectInGlobal(roomObjectName) {\r\n        // Stop if there is no stored object\r\n        if (!global[room.name][roomObjectName])\r\n            return;\r\n        //\r\n        const cacheAmount = global[room.name][roomObjectName].cacheAmount;\r\n        const lastCache = global[room.name][roomObjectName].lastCache;\r\n        // Stop if time is greater than lastCache + cacheAmount\r\n        if (lastCache + cacheAmount < Game.time)\r\n            return;\r\n        // See if roomObject's type is an id\r\n        if (global[room.name][roomObjectName].type == 'id') {\r\n            return global.findObjectWithId(global[room.name][roomObjectName].value);\r\n        }\r\n        // See if roomObject's type is an pos\r\n        if (global[room.name][roomObjectName].type == 'pos') {\r\n            // Return roomPosition of pos\r\n            return room.newPos(global[room.name][roomObjectName].value);\r\n        }\r\n        // Return the value of the roomObject\r\n        return global[room.name][roomObjectName].value;\r\n    }\r\n    /**\r\n     *\r\n     * @param roomObjectName name of roomObject\r\n     * @returns roomObject\r\n     */\r\n    function findRoomObjectInMemory(roomObjectName) {\r\n        // Stop if there is no stored object\r\n        if (!room.memory[roomObjectName])\r\n            return;\r\n        // See if roomObject's type is an id\r\n        if (room.memory[roomObjectName].type == 'id') {\r\n            // Return roomObject with id\r\n            return global.findObjectWithId(room.memory[roomObjectName].value);\r\n        }\r\n        // See if roomObject's type is an pos\r\n        if (room.memory[roomObjectName].type == 'pos') {\r\n            // Return roomPosition of pos\r\n            return room.newPos(room.memory[roomObjectName].value);\r\n        }\r\n        // Return the value of the roomObject\r\n        return room.memory[roomObjectName].value;\r\n    }\r\n    /**\r\n     * @param value roomObject\r\n     * @param cacheAmount if in global, how long to store roomObject for\r\n     * @param storeMethod where to store the roomObject\r\n     * @param type object, id, or pos\r\n     */\r\n    class RoomObject {\r\n        constructor(value, cacheAmount, storeMethod, type) {\r\n            this.value = value;\r\n            this.type = type;\r\n            if (storeMethod == 'global') {\r\n                this.cacheAmount = cacheAmount;\r\n                this.lastCache = Game.time;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    //\r\n    let roomObjects = {};\r\n    // Important Positions\r\n    roomObjects.anchorPoint = findRoomObjectInMemory('anchorPoint') || new RoomObject(room.newPos(room.memory.anchorPoint), Infinity, 'memory', 'pos');\r\n    // Resources\r\n    roomObjects.mineral = findRoomObjectInGlobal('mineral') || new RoomObject(room.find(FIND_MINERALS)[0], Infinity, 'global', 'object');\r\n    roomObjects.sources = findRoomObjectInGlobal('sources') || new RoomObject(room.find(FIND_SOURCES), Infinity, 'global', 'object');\r\n    roomObjects.source1 = findRoomObjectInMemory('source1') || new RoomObject(roomObjects.sources.value[0], Infinity, 'memory', 'id');\r\n    if (roomObjects.sources[1])\r\n        roomObjects.source2 = findRoomObjectInMemory('source2') || new RoomObject(roomObjects.sources.value[1], Infinity, 'memory', 'id');\r\n    // Loop through all structres in room\r\n    for (let structure of room.find(FIND_STRUCTURES)) {\r\n        // Create catagory if it doesn't exist\r\n        if (!roomObjects[structure.structureType])\r\n            roomObjects[structure.structureType] = new RoomObject([], 1, 'global', 'object');\r\n        // Group structure by structureType\r\n        roomObjects[structure.structureType].value.push(structure);\r\n    }\r\n    // Harvest positions\r\n    roomObjects.source1HarvestPositions = findRoomObjectInGlobal('source1HarvestPositions') || new RoomObject(findHarvestPositions(roomObjects.source1.value), Infinity, 'global', 'object');\r\n    roomObjects.source1ClosestHarvestPosition = findRoomObjectInGlobal('source1ClosestHarvestPosition') || new RoomObject(findClosestHarvestPosition(roomObjects.source1HarvestPositions.value), Infinity, 'memory', 'object');\r\n    if (roomObjects.sources[1])\r\n        roomObjects.source2HarvestPositions = findRoomObjectInGlobal('source2HarvestPositions') || new RoomObject(findHarvestPositions(roomObjects.source2.value), Infinity, 'global', 'object');\r\n    if (roomObjects.sources[1])\r\n        roomObjects.source2ClosestHarvestPosition = findRoomObjectInGlobal('source2ClosestHarvestPosition') || new RoomObject(findClosestHarvestPosition(roomObjects.source2HarvestPositions.value), Infinity, 'memory', 'object');\r\n    /**\r\n     * Finds positions adjacent to a source that a creep can harvest\r\n     * @param source source object\r\n     * @returns sources harvest positions\r\n     */\r\n    function findHarvestPositions(source) {\r\n        // Find positions adjacent to source\r\n        const rect = { x1: source.pos.x - 1, y1: source.pos.y - 1, x2: source.pos.x + 1, y2: source.pos.y + 1 };\r\n        const adjacentPositions = global.getPositionsInsideRect(rect);\r\n        let harvestPositions = [];\r\n        // Find terrain in room\r\n        const terrain = Game.map.getRoomTerrain(room.name);\r\n        for (let pos of adjacentPositions) {\r\n            // Iterate if terrain for pos isn't wall\r\n            if (terrain.get(pos.x, pos.y) != TERRAIN_MASK_WALL)\r\n                continue;\r\n            // Convert position into a RoomPosition\r\n            pos = room.newPos(pos);\r\n            // Add pos to harvestPositions\r\n            harvestPositions.push(pos);\r\n        }\r\n        return harvestPositions;\r\n    }\r\n    function findClosestHarvestPosition(harvestPositions) {\r\n        // Filter harvestPositions by closest one to anchorPoint\r\n        return roomObjects.anchorPoint.value.findClosestByRange(harvestPositions);\r\n    }\r\n    // Return queried value\r\n    return roomObjects[roomObjectName].value;\r\n};\r\nRoom.prototype.newPos = function (object) {\r\n    const room = this;\r\n    // Create an return roomPosition\r\n    return new RoomPosition(object.x, object.y, room.name);\r\n};\r\n//# sourceMappingURL=roomFunctions.js.map","references":[],"map":"{\"version\":3,\"file\":\"roomFunctions.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/room/roomFunctions.ts\"],\"names\":[],\"mappings\":\"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\"}"}
